<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五年级密铺图案设计</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            padding: 20px;
        }
        
        .tool-panel {
            flex: 1;
            min-width: 300px;
            padding: 20px;
            background-color: #f9f9f9;
            border-radius: 8px;
            margin-right: 20px;
        }
        
        .canvas-container {
            flex: 2;
            min-width: 500px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.05);
            padding: 15px;
            position: relative;
        }
        
        canvas {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            display: block;
            margin: 0 auto;
            cursor: default;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        h2 {
            font-size: 1.4rem;
            color: #2575fc;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid #eee;
        }
        
        .shape-options, .tool-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .btn-shape {
            background-color: #e9ecef;
            flex: 1;
            min-width: 120px;
        }
        
        .btn-shape:hover {
            background-color: #dee2e6;
        }
        
        .btn-shape.active {
            background-color: #2575fc;
            color: white;
        }
        
        .btn-tool {
            background-color: #e9ecef;
            flex: 1;
            min-width: 100px;
        }
        
        .btn-tool:hover {
            background-color: #dee2e6;
        }
        
        .btn-tool.active {
            background-color: #6a11cb;
            color: white;
        }
        
        .btn-action {
            background-color: #28a745;
            color: white;
            width: 100%;
            padding: 12px;
            font-size: 1.1rem;
            margin-top: 10px;
        }
        
        .btn-action:hover {
            background-color: #218838;
        }
        
        .btn-return {
            background-color: #6c757d;
            color: white;
            width: 100%;
            padding: 12px;
            font-size: 1.1rem;
            margin-top: 10px;
        }
        
        .btn-return:hover {
            background-color: #5a6268;
        }
        
        .instructions {
            background-color: #e7f3ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 0.95rem;
        }
        
        .instructions h3 {
            color: #2575fc;
            margin-bottom: 10px;
        }
        
        .instructions ol {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .tiling-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .tiling-controls input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 80px;
        }
        
        footer {
            text-align: center;
            padding: 15px;
            color: #6c757d;
            font-size: 0.9rem;
            border-top: 1px solid #eee;
        }
        
        @media (max-width: 900px) {
            .content {
                flex-direction: column;
            }
            
            .tool-panel {
                margin-right: 0;
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>五年级密铺图案设计</h1>
            <p class="subtitle">设计你的独特密铺图案，探索数学之美</p>
        </header>
        
        <div class="content">
            <div class="tool-panel">
                <div class="section">
                    <h2>选择基础图形</h2>
                    <div class="shape-options">
                        <button class="btn btn-shape active" data-shape="square">正方形</button>
                        <button class="btn btn-shape" data-shape="rectangle">长方形</button>
                        <button class="btn btn-shape" data-shape="parallelogram">平行四边形</button>
                    </div>
                </div>
                
                <div class="section">
                    <h2>选择工具</h2>
                    <div class="tool-options">
                        <button class="btn btn-tool active" data-tool="line">线段</button>
                        <button class="btn btn-tool" data-tool="adjust">调整线段</button>
                        <button class="btn btn-tool" data-tool="move">移动图形</button>
                        <button class="btn btn-tool" data-tool="erase">擦除</button>
                    </div>
                </div>
                
                <div class="section">
                    <h2>操作</h2>
                    <div class="tiling-controls">
                        <div>
                            <label>行数:</label>
                            <input type="number" id="rows" min="1" max="20" value="8">
                        </div>
                        <div>
                            <label>列数:</label>
                            <input type="number" id="cols" min="1" max="20" value="10">
                        </div>
                    </div>
                    <button class="btn btn-action" id="generateTiling">生成密铺图案</button>
                    <button class="btn btn-return" id="returnDesign">返回设计</button>
                    <button class="btn btn-action" id="reset">重置设计</button>
                </div>
                
                <div class="instructions">
                    <h3>使用说明</h3>
                    <ol>
                        <li>选择基础图形（正方形、长方形或平行四边形）</li>
                        <li>使用线段工具：点击确定起点和终点绘制线段</li>
                        <li>线段可以不与原图形形成交点，可以在图形内部绘制</li>
                        <li>使用调整线段工具：拖动线段端点调整位置</li>
                        <li>使用移动图形工具：拖动分割后的图形到新位置（可移出原四边形）</li>
                        <li>使用擦除工具：点击要删除的线段</li>
                        <li>设置密铺的行数和列数</li>
                        <li>点击"生成密铺图案"查看效果</li>
                        <li>点击"返回设计"查看原始设计</li>
                    </ol>
                </div>
            </div>
            
            <div class="canvas-container">
                <canvas id="designCanvas" width="600" height="500"></canvas>
            </div>
        </div>
        
        <footer>
            <p>五年级数学密铺教学工具 | 设计：数学教研组</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('designCanvas');
            const ctx = canvas.getContext('2d');
            
            // 状态管理
            const state = {
                currentShapeType: 'square',
                currentTool: 'line',
                isDrawing: false,
                drawingStep: 0,
                points: [],
                lines: [],
                shapes: [],
                originalBaseShape: null, // 保存原始基础图形
                selectedShape: null,
                selectedLine: null,
                selectedEndpoint: null,
                isMoving: false,
                isAdjusting: false,
                offsetX: 0,
                offsetY: 0,
                showTiling: false,
                tilingRows: 8,
                tilingCols: 10
            };
            
            // 固定的基础图形定义
            const baseShapes = {
                square: {
                    points: [
                        { x: 200, y: 150 },
                        { x: 350, y: 150 },
                        { x: 350, y: 300 },
                        { x: 200, y: 300 }
                    ]
                },
                rectangle: {
                    points: [
                        { x: 175, y: 175 },
                        { x: 375, y: 175 },
                        { x: 375, y: 275 },
                        { x: 175, y: 275 }
                    ]
                },
                parallelogram: {
                    points: [
                        { x: 200, y: 175 },
                        { x: 350, y: 175 },
                        { x: 320, y: 275 },
                        { x: 170, y: 275 }
                    ]
                }
            };
            
            // 绘制函数
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                if (state.showTiling) {
                    drawTiling();
                } else {
                    drawDesign();
                }
            }
            
            // 绘制设计
            function drawDesign() {
                const base = baseShapes[state.currentShapeType];
                if (state.shapes.length === 0) {
                    // 只绘制基础图形的边框
                    ctx.fillStyle = 'white';
                    ctx.strokeStyle = '#6c757d';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(base.points[0].x, base.points[0].y);
                    for (let i = 1; i < base.points.length; i++) {
                        ctx.lineTo(base.points[i].x, base.points[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else {
                    // 绘制分割后的形状
                    state.shapes.forEach(shape => {
                        if (shape.points.length > 0) {
                            ctx.fillStyle = shape.color;
                            ctx.beginPath();
                            ctx.moveTo(shape.points[0].x, shape.points[0].y);
                            for (let i = 1; i < shape.points.length; i++) {
                                ctx.lineTo(shape.points[i].x, shape.points[i].y);
                            }
                            ctx.closePath();
                            ctx.fill();
                            
                            // 绘制形状的边线，使用与填充色相近的颜色
                            const strokeColor = getDarkerColor(shape.color);
                            ctx.strokeStyle = strokeColor;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            if (shape === state.selectedShape) {
                                ctx.strokeStyle = '#ffeb3b';
                                ctx.lineWidth = 3;
                                ctx.stroke();
                            }
                        }
                    });
                }
                
                // 只绘制用户画的线段（在设计模式下）
                if (!state.showTiling) {
                    state.lines.forEach(line => {
                        // 使用与填充色相近的颜色绘制线段
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(line.startX, line.startY);
                        ctx.lineTo(line.endX, line.endY);
                        ctx.stroke();
                        
                        // 绘制端点（只有在调整模式下）
                        if (state.currentTool === 'adjust') {
                            drawEndpoint(line.startX, line.startY, line === state.selectedLine && state.selectedEndpoint === 'start');
                            drawEndpoint(line.endX, line.endY, line === state.selectedLine && state.selectedEndpoint === 'end');
                        }
                    });
                }
                
                // 绘制当前正在绘制的线段
                if (state.isDrawing && state.currentTool === 'line') {
                    if (state.drawingStep === 1 && state.points.length >= 1) {
                        const startPoint = state.points[0];
                        ctx.strokeStyle = '#3498db';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.lineTo(state.currentX, state.currentY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    // 绘制已确定的点
                    state.points.forEach(point => {
                        drawEndpoint(point.x, point.y, false);
                    });
                }
            }
            
            // 根据填充色生成更深的边线颜色
            function getDarkerColor(color) {
                // 将十六进制颜色转换为RGB
                let r = parseInt(color.substring(1, 3), 16);
                let g = parseInt(color.substring(3, 5), 16);
                let b = parseInt(color.substring(5, 7), 16);
                
                // 减少亮度
                r = Math.max(0, r - 50);
                g = Math.max(0, g - 50);
                b = Math.max(0, b - 50);
                
                // 转换回十六进制
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            // 绘制端点
            function drawEndpoint(x, y, isSelected) {
                ctx.fillStyle = isSelected ? '#ff5722' : '#3498db';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // 绘制密铺
            function drawTiling() {
                // 清除画布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 计算基础图形的向量
                const base = baseShapes[state.currentShapeType].points;
                const vCol = { x: base[1].x - base[0].x, y: base[1].y - base[0].y };
                const vRow = { x: base[3].x - base[0].x, y: base[3].y - base[0].y };
                
                // 计算基础图形的中心
                const baseCenterX = (base[0].x + base[1].x + base[2].x + base[3].x) / 4;
                const baseCenterY = (base[0].y + base[1].y + base[2].y + base[3].y) / 4;
                
                // 计算整体偏移量，使密铺居中
                const offsetX = (canvas.width - state.tilingCols * vCol.x - state.tilingRows * vRow.x) / 2;
                const offsetY = (canvas.height - state.tilingCols * vCol.y - state.tilingRows * vRow.y) / 2;
                
                // 绘制背景
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 绘制密铺
                for (let row = 0; row < state.tilingRows; row++) {
                    for (let col = 0; col < state.tilingCols; col++) {
                        const xTranslation = col * vCol.x + row * vRow.x + offsetX;
                        const yTranslation = col * vCol.y + row * vRow.y + offsetY;
                        
                        // 绘制当前形状的所有分割部分
                        state.shapes.forEach(shape => {
                            if (shape.points.length === 0) return;
                            
                            ctx.fillStyle = shape.color;
                            ctx.beginPath();
                            ctx.moveTo(shape.points[0].x + xTranslation, shape.points[0].y + yTranslation);
                            
                            for (let i = 1; i < shape.points.length; i++) {
                                ctx.lineTo(shape.points[i].x + xTranslation, shape.points[i].y + yTranslation);
                            }
                            
                            ctx.closePath();
                            ctx.fill();
                            
                            // 绘制形状的边线，使用与填充色相近的颜色
                            const strokeColor = getDarkerColor(shape.color);
                            ctx.strokeStyle = strokeColor;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        });
                    }
                }
            }
            
            // 检查点是否在基础图形内
            function isPointInBaseShape(x, y) {
                const shape = baseShapes[state.currentShapeType];
                return isPointInPolygon(x, y, shape.points);
            }
            
            // 获取线段端点
            function getLineEndpoint(line, x, y) {
                const startDist = Math.sqrt((x - line.startX) ** 2 + (y - line.startY) ** 2);
                const endDist = Math.sqrt((x - line.endX) ** 2 + (y - line.endY) ** 2);
                
                if (startDist < 10) return 'start';
                if (endDist < 10) return 'end';
                return null;
            }
            
            // 事件监听
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            
            function handleMouseDown(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                state.currentX = x;
                state.currentY = y;
                
                if (state.currentTool === 'move') {
                    // 检查是否点击了分割后的形状 - 从后往前检查，确保选中顶层的形状
                    state.selectedShape = null;
                    for (let i = state.shapes.length - 1; i >= 0; i--) {
                        // 使用当前形状的点集来检测点击
                        if (isPointInPolygon(x, y, state.shapes[i].points)) {
                            state.selectedShape = state.shapes[i];
                            state.isMoving = true;
                            // 计算鼠标相对于形状第一个点的偏移
                            state.offsetX = x - state.selectedShape.points[0].x;
                            state.offsetY = y - state.selectedShape.points[0].y;
                            break;
                        }
                    }
                } else if (state.currentTool === 'adjust') {
                    // 检查是否点击了线段端点
                    state.selectedLine = null;
                    state.selectedEndpoint = null;
                    
                    for (let i = state.lines.length - 1; i >= 0; i--) {
                        const line = state.lines[i];
                        const endpoint = getLineEndpoint(line, x, y);
                        if (endpoint) {
                            state.selectedLine = line;
                            state.selectedEndpoint = endpoint;
                            state.isAdjusting = true;
                            state.offsetX = x - (endpoint === 'start' ? line.startX : line.endX);
                            state.offsetY = y - (endpoint === 'start' ? line.startY : line.endY);
                            break;
                        }
                    }
                } else if (state.currentTool === 'erase') {
                    // 擦除工具
                    for (let i = state.lines.length - 1; i >= 0; i--) {
                        const line = state.lines[i];
                        if (isPointOnLine(x, y, line.startX, line.startY, line.endX, line.endY)) {
                            state.lines.splice(i, 1);
                            break;
                        }
                    }
                } else if (state.currentTool === 'line') {
                    // 线段工具 - 现在允许在基础图形内绘制
                    if (state.isDrawing) {
                        state.drawingStep++;
                        state.points.push({x: x, y: y});
                        
                        // 完成绘制
                        if (state.drawingStep === 2) {
                            state.lines.push({
                                startX: state.points[0].x,
                                startY: state.points[0].y,
                                endX: state.points[1].x,
                                endY: state.points[1].y
                            });
                            
                            // 生成新的分割形状
                            generateShapesFromLines();
                            
                            // 重置绘制状态
                            state.isDrawing = false;
                            state.drawingStep = 0;
                            state.points = [];
                        }
                    } else {
                        state.isDrawing = true;
                        state.drawingStep = 1;
                        state.points = [{x: x, y: y}];
                    }
                }
                
                draw();
            }
            
            function handleMouseMove(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                state.currentX = x;
                state.currentY = y;
                
                // 更新光标样式
                updateCursor(x, y);
                
                if (state.isMoving && state.selectedShape) {
                    // 计算移动距离
                    const dx = x - state.offsetX - state.selectedShape.points[0].x;
                    const dy = y - state.offsetX - state.selectedShape.points[0].y;
                    
                    // 移动选中的形状的所有点
                    for (let i = 0; i < state.selectedShape.points.length; i++) {
                        state.selectedShape.points[i].x += dx;
                        state.selectedShape.points[i].y += dy;
                    }
                } else if (state.isAdjusting && state.selectedLine) {
                    // 调整线段端点
                    if (state.selectedEndpoint === 'start') {
                        state.selectedLine.startX = x - state.offsetX;
                        state.selectedLine.startY = y - state.offsetX;
                    } else if (state.selectedEndpoint === 'end') {
                        state.selectedLine.endX = x - state.offsetX;
                        state.selectedLine.endY = y - state.offsetX;
                    }
                    // 重新生成形状（将线段视为无限延长以切分）
                    generateShapesFromLines();
                }
                
                draw();
            }
            
            function handleMouseUp(e) {
                state.isMoving = false;
                state.isAdjusting = false;
                draw();
            }
            
            // 更新光标样式
            function updateCursor(x, y) {
                if (state.currentTool === 'move') {
                    for (let i = state.shapes.length - 1; i >= 0; i--) {
                        if (isPointInPolygon(x, y, state.shapes[i].points)) {
                            canvas.style.cursor = 'grab';
                            return;
                        }
                    }
                    canvas.style.cursor = 'default';
                } else if (state.currentTool === 'adjust') {
                    for (let i = state.lines.length - 1; i >= 0; i--) {
                        const line = state.lines[i];
                        const endpoint = getLineEndpoint(line, x, y);
                        if (endpoint) {
                            canvas.style.cursor = 'pointer';
                            return;
                        }
                    }
                    canvas.style.cursor = 'default';
                } else if (state.currentTool === 'erase') {
                    for (let i = state.lines.length - 1; i >= 0; i--) {
                        const line = state.lines[i];
                        if (isPointOnLine(x, y, line.startX, line.startY, line.endX, line.endY)) {
                            canvas.style.cursor = 'not-allowed';
                            return;
                        }
                    }
                    canvas.style.cursor = 'default';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
            
            // 判断点是否在线段上
            function isPointOnLine(px, py, x1, y1, x2, y2) {
                const lineLength = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                const distance = Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) / lineLength;
                return distance < 5; // 容差范围
            }
            
            // 根据线段生成分割形状 - 使用边界延长+路径遍历
            function generateShapesFromLines() {
                const baseShape = baseShapes[state.currentShapeType];
                // 从基础图形开始（即使没有线段也保留基础形状，便于移动）
                let currentShapes = [{
                    points: baseShape.points.map(p => ({...p})),
                    color: '#a8e6cf',
                    original: true
                }];
                
                // 对每条线段依次分割现有形状
                for (let lineIndex = 0; lineIndex < state.lines.length; lineIndex++) {
                    const line = state.lines[lineIndex];
                    
                    // 检查线段是否在基础图形内部
                    const isStartInside = isPointInBaseShape(line.startX, line.startY);
                    const isEndInside = isPointInBaseShape(line.endX, line.endY);
                    
                    // 如果线段完全在图形外部，跳过
                    if (!isStartInside && !isEndInside) {
                        continue;
                    }
                    
                    // 如果线段部分在图形内部，则延长到边界
                    let extendedLine = { ...line };
                    if (!isStartInside || !isEndInside) {
                        // 找到线段与图形边界的交点，延长线段
                        const extended = extendLineToPolygonBoundary(line, baseShape.points);
                        if (extended) {
                            extendedLine = {
                                startX: extended.a.x,
                                startY: extended.a.y,
                                endX: extended.b.x,
                                endY: extended.b.y
                            };
                        }
                    }
                    
                    const newShapes = [];
                    
                    // 对每个当前形状进行分割
                    for (let shapeIndex = 0; shapeIndex < currentShapes.length; shapeIndex++) {
                        const shape = currentShapes[shapeIndex];
                        const splitShapes = splitShapeByLine(shape, extendedLine);
                        newShapes.push(...splitShapes);
                    }
                    
                    currentShapes = newShapes;
                }
                
                // 按面积排序，找出面积最小的形状（三条线段组成的图形）
                currentShapes.sort((a, b) => calculatePolygonArea(a.points) - calculatePolygonArea(b.points));
                
                // 分配颜色：最小的图形用一种颜色，其他用另一种颜色
                const smallestShape = currentShapes[0];
                for (let i = 0; i < currentShapes.length; i++) {
                    if (currentShapes[i] === smallestShape) {
                        currentShapes[i].color = '#a8e6cf'; // 绿色
                    } else {
                        currentShapes[i].color = '#dcedc1'; // 黄色
                    }
                }
                
                state.shapes = currentShapes;
            }
            
            // 计算多边形面积
            function calculatePolygonArea(points) {
                if (points.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < points.length; i++) {
                    const j = (i + 1) % points.length;
                    area += points[i].x * points[j].y;
                    area -= points[j].x * points[i].y;
                }
                
                return Math.abs(area) / 2;
            }
            
            // 检查线段是否与形状相交
            function lineIntersectsShape(line, shapePoints) {
                for (let i = 0; i < shapePoints.length; i++) {
                    const p1 = shapePoints[i];
                    const p2 = shapePoints[(i + 1) % shapePoints.length];
                    
                    if (lineSegmentsIntersect(line.startX, line.startY, line.endX, line.endY, 
                                             p1.x, p1.y, p2.x, p2.y)) {
                        return true;
                    }
                }
                return false;
            }
            
            // 检查两条线段是否相交
            function lineSegmentsIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (denom === 0) return false;
                
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
                
                return t >= 0 && t <= 1 && u >= 0 && u <= 1;
            }
            
            // 通过线段分割形状 - 边界延长并切分
            function splitShapeByLine(shape, line) {
                const poly = shape.points;
                const ext = extendLineToPolygonBoundary(line, poly);
                if (!ext) return [shape];
                const { a, b } = ext; // a.edgeIndex, b.edgeIndex, a.x/y, b.x/y
                // a -> b 沿多边形
                const pathAB = [];
                pathAB.push({ x: a.x, y: a.y });
                let idx = a.edgeIndex;
                while (idx !== b.edgeIndex) {
                    const nextVertexIndex = (idx + 1) % poly.length;
                    pathAB.push({ x: poly[nextVertexIndex].x, y: poly[nextVertexIndex].y });
                    idx = (idx + 1) % poly.length;
                }
                pathAB.push({ x: b.x, y: b.y });
                // b -> a 沿多边形
                const pathBA = [];
                pathBA.push({ x: b.x, y: b.y });
                idx = b.edgeIndex;
                while (idx !== a.edgeIndex) {
                    const nextVertexIndex = (idx + 1) % poly.length;
                    pathBA.push({ x: poly[nextVertexIndex].x, y: poly[nextVertexIndex].y });
                    idx = (idx + 1) % poly.length;
                }
                pathBA.push({ x: a.x, y: a.y });
                const leftShape = ensureClosedShape(pathAB);
                const rightShape = ensureClosedShape(pathBA);
                const result = [];
                if (leftShape.length >= 3) result.push({ points: leftShape, color: '#a8e6cf' });
                if (rightShape.length >= 3) result.push({ points: rightShape, color: '#dcedc1' });
                return result.length > 0 ? result : [shape];
            }
            
            // 确保形状是闭合的
            function ensureClosedShape(points) {
                if (points.length < 3) return points;
                
                // 简单的闭合处理：确保首尾点相同
                const result = [...points];
                
                // 如果首尾点不相同，添加第一个点到末尾
                if (Math.abs(result[0].x - result[result.length - 1].x) > 1 || 
                    Math.abs(result[0].y - result[result.length - 1].y) > 1) {
                    result.push({...result[0]});
                }
                
                return result;
            }
            
            // 计算两条线的交点
            function getLineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (denom === 0) return null;
                
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
                
                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                    return {
                        x: x1 + t * (x2 - x1),
                        y: y1 + t * (y2 - y1)
                    };
                }
                
                return null;
            }
            
            // 判断点是否在多边形内
            function isPointInPolygon(x, y, polygon) {
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    const xi = polygon[i].x, yi = polygon[i].y;
                    const xj = polygon[j].x, yj = polygon[j].y;
                    
                    const intersect = ((yi > y) !== (yj > y)) &&
                        (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }
            
            // 无限直线与有界线段的交点（仅检查线段参数范围）
            function getInfiniteLineAndSegmentIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
                const EPS = 1e-6;
                const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
                if (Math.abs(denom) < EPS) return null;
                const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom; // 在线的参数
                const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom; // 在线段的参数
                if (u < -EPS || u > 1 + EPS) return null;
                return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1), tOnLine: t };
            }
            
            function pointsAlmostEqual(a, b, eps = 1e-5) {
                return Math.abs(a.x - b.x) < eps && Math.abs(a.y - b.y) < eps;
            }
            
            // 将用户线段延长到当前形状边界，返回两端交点
            function extendLineToPolygonBoundary(line, polygon) {
                const intersections = [];
                for (let i = 0; i < polygon.length; i++) {
                    const p1 = polygon[i];
                    const p2 = polygon[(i + 1) % polygon.length];
                    const inter = getInfiniteLineAndSegmentIntersection(
                        line.startX, line.startY, line.endX, line.endY,
                        p1.x, p1.y, p2.x, p2.y
                    );
                    if (inter) {
                        inter.edgeIndex = i;
                        if (!intersections.some(pt => pointsAlmostEqual(pt, inter))) {
                            intersections.push(inter);
                        }
                    }
                }
                if (intersections.length < 2) return null;
                intersections.sort((a, b) => a.tOnLine - b.tOnLine);
                const a = intersections[0];
                const b = intersections[intersections.length - 1];
                return { a, b };
            }

            // 计算多边形有向面积（>0 表示逆时针）
            function polygonAreaSigned(poly) {
                let area2 = 0;
                for (let i = 0, n = poly.length; i < n; i++) {
                    const j = (i + 1) % n;
                    area2 += poly[i].x * poly[j].y - poly[j].x * poly[i].y;
                }
                return area2 / 2;
            }

            // 凸多边形裁剪（Sutherland–Hodgman），将 subject 裁剪到 clip 内
            function clipPolygonConvex(subject, clip) {
                if (!subject || subject.length < 3) return [];
                if (!clip || clip.length < 3) return [];
                const isCCW = polygonAreaSigned(clip) > 0;
                function isInside(p, a, b) {
                    const cross = (b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x);
                    return isCCW ? cross >= 0 : cross <= 0;
                }
                function computeIntersection(s, e, a, b) {
                    // 交点：裁剪边(a->b)作为无限直线，与被裁线段(s->e)
                    return getInfiniteLineAndSegmentIntersection(a.x, a.y, b.x, b.y, s.x, s.y, e.x, e.y);
                }
                let output = subject.slice();
                for (let i = 0; i < clip.length; i++) {
                    const a = clip[i];
                    const b = clip[(i + 1) % clip.length];
                    const input = output.slice();
                    output = [];
                    if (input.length === 0) break;
                    let S = input[input.length - 1];
                    for (let j = 0; j < input.length; j++) {
                        const E = input[j];
                        const Ein = isInside(E, a, b);
                        const Sin = isInside(S, a, b);
                        if (Ein) {
                            if (!Sin) {
                                const I = computeIntersection(S, E, a, b);
                                if (I) output.push({ x: I.x, y: I.y });
                            }
                            output.push(E);
                        } else if (Sin) {
                            const I = computeIntersection(S, E, a, b);
                            if (I) output.push({ x: I.x, y: I.y });
                        }
                        S = E;
                    }
                }
                return output;
            }
            
            // UI事件处理
            document.querySelectorAll('.btn-shape').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.btn-shape').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    state.currentShapeType = this.dataset.shape;
                    state.showTiling = false;
                    // 重置设计
                    state.lines = [];
                    generateShapesFromLines();
                    draw();
                });
            });
            
            document.querySelectorAll('.btn-tool').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.btn-tool').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    state.currentTool = this.dataset.tool;
                    state.isDrawing = false;
                    state.drawingStep = 0;
                    state.points = [];
                    state.selectedLine = null;
                    state.selectedShape = null;
                    draw();
                });
            });
            
            document.getElementById('generateTiling').addEventListener('click', function() {
                state.tilingRows = parseInt(document.getElementById('rows').value);
                state.tilingCols = parseInt(document.getElementById('cols').value);
                state.showTiling = true;
                draw();
            });
            
            document.getElementById('returnDesign').addEventListener('click', function() {
                state.showTiling = false;
                draw();
            });
            
            document.getElementById('reset').addEventListener('click', function() {
                state.lines = [];
                state.selectedShape = null;
                state.selectedLine = null;
                state.isDrawing = false;
                state.drawingStep = 0;
                state.points = [];
                state.showTiling = false;
                generateShapesFromLines();
                draw();
            });
            
            // 初始绘制
            generateShapesFromLines();
            draw();
        });
    </script>
</body>
</html>



